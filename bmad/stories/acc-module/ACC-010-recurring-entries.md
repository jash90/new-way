# ACC-010: Recurring Entries

## Story Information
| Field | Value |
|-------|-------|
| **Story ID** | ACC-010 |
| **Epic** | ACC - Accounting Engine |
| **Title** | Recurring Entries |
| **Priority** | P2 |
| **Points** | 8 |
| **Status** | Draft |
| **Sprint** | Week 10 |
| **Dependencies** | ACC-006 (Journal Entries), ACC-009 (Templates) |

---

## User Story

**As a** ksiÄ™gowy (accountant),
**I want to** set up automatic generation of recurring journal entries based on schedules,
**So that** regular transactions like monthly depreciation, rent, or insurance amortization are automatically created without manual intervention.

---

## Acceptance Criteria

### AC1: Recurring Entry Schedule Creation
```gherkin
Feature: Recurring Entry Schedule Creation

Scenario: Create monthly recurring entry
  Given I am an authenticated accountant
  And I have a journal entry template "Monthly Depreciation"
  When I create a recurring schedule
  And I set frequency to "Monthly"
  And I set day of month to 31 (or last day)
  And I set start date to "2024-01-01"
  And I set end date to "2024-12-31" (optional)
  And I enable the schedule
  Then a recurring entry schedule is created
  And the next run date is calculated as "2024-01-31"
  And an audit log entry is recorded

Scenario: Create weekly recurring entry
  Given I have a template for weekly payroll accrual
  When I create a recurring schedule
  And I set frequency to "Weekly"
  And I set day of week to "Friday"
  Then the schedule is created
  And next run dates are every Friday

Scenario: Create custom frequency schedule
  Given I need to accrue quarterly insurance expense
  When I create a recurring schedule
  And I set frequency to "Custom"
  And I set interval to "3 months"
  Then the schedule runs every 3 months from start date

Scenario: Create schedule with variable amounts
  Given I have a template with variable amounts
  When I create a recurring schedule
  And I provide default variable values for automation
  Then the schedule uses default values for auto-generated entries
  And I can override values for specific occurrences
```

### AC2: Schedule Management
```gherkin
Feature: Schedule Management

Scenario: View all recurring schedules
  Given I have 5 active and 2 paused recurring schedules
  When I navigate to the recurring entries page
  Then I see all schedules with their status
  And I can filter by status (Active, Paused, Completed, Expired)
  And I see next run date for each active schedule

Scenario: Pause recurring schedule
  Given I have an active schedule "Monthly Depreciation"
  When I pause the schedule
  Then the status changes to "PAUSED"
  And no entries are generated until resumed
  And the paused date is recorded

Scenario: Resume paused schedule
  Given I have a paused schedule
  When I resume the schedule
  And I choose to "Generate missed entries" for the paused period
  Then the status changes to "ACTIVE"
  And entries are generated for the missed periods
  And the next run date is recalculated

Scenario: Modify schedule parameters
  Given I have an active schedule
  When I change the frequency from "Monthly" to "Quarterly"
  Then the schedule is updated
  And next run date is recalculated
  And future entries will follow the new frequency

Scenario: Delete recurring schedule
  Given I have a schedule I no longer need
  When I delete the schedule
  Then the schedule is soft-deleted (archived)
  And existing entries generated by this schedule are not affected
  And the schedule can be restored if needed
```

### AC3: Automatic Entry Generation
```gherkin
Feature: Automatic Entry Generation

Scenario: System generates scheduled entry
  Given I have an active recurring schedule
  And the next run date is today
  When the scheduler job runs
  Then a new journal entry is created from the template
  And the entry is created as DRAFT or auto-posted based on schedule settings
  And the next run date is updated
  And a notification is sent to the accountant

Scenario: Handle generation failure
  Given a scheduled entry should be generated
  And there is a validation error (e.g., closed period)
  When the scheduler attempts to generate
  Then the error is logged
  And an alert notification is sent to the accountant
  And the schedule retry count is incremented
  And the system will retry on the next scheduler run

Scenario: Skip weekends and holidays
  Given a schedule is set to run on the 25th of each month
  And the 25th falls on a Saturday
  And the schedule is configured to skip weekends
  When the run date is calculated
  Then the entry is generated on the previous Friday (23rd)
  Or the next Monday (27th) based on configuration

Scenario: End of month handling
  Given a schedule is set for day 31
  And the current month is February
  When the run date is calculated
  Then the entry is generated on February 28 (or 29 in leap year)
```

### AC4: Batch Generation and Preview
```gherkin
Feature: Batch Generation and Preview

Scenario: Preview upcoming entries
  Given I have 3 active recurring schedules
  When I view "Upcoming Entries" for next 30 days
  Then I see a list of entries that will be generated
  And I can see amounts, dates, and source schedules
  And I can filter by schedule or date range

Scenario: Manually trigger generation
  Given I have an active schedule with next run date in the future
  When I click "Generate Now"
  Then an entry is created immediately
  And the next run date remains unchanged
  And this is marked as a manual generation in audit log

Scenario: Batch generate missed entries
  Given a schedule was paused and resumed
  And there are 3 missed entries
  When I select "Generate Missed Entries"
  Then all 3 entries are created
  And each entry has the correct date from the schedule
  And the entries are created as drafts for review
```

### AC5: Notifications and Monitoring
```gherkin
Feature: Notifications and Monitoring

Scenario: Receive notification on entry generation
  Given I have enabled notifications for a schedule
  When an entry is automatically generated
  Then I receive an email notification
  And the notification includes entry details
  And I can click to view the entry directly

Scenario: Alert on generation failure
  Given a scheduled generation fails
  When the error occurs
  Then an alert notification is sent immediately
  And the alert includes error details
  And the schedule dashboard shows warning indicator

Scenario: View schedule execution history
  Given I have a recurring schedule
  When I view the schedule details
  Then I see a history of all executions
  And I can see success/failure status
  And I can see generated entry links
  And I can see error messages for failures
```

---

## Technical Specification

### Database Schema

```sql
-- Recurring entry schedules
CREATE TABLE recurring_entry_schedules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),

  -- Schedule identification
  schedule_code VARCHAR(50) NOT NULL,
  schedule_name VARCHAR(255) NOT NULL,
  description TEXT,

  -- Template reference
  template_id UUID NOT NULL REFERENCES journal_entry_templates(id),

  -- Frequency configuration
  frequency VARCHAR(20) NOT NULL, -- DAILY, WEEKLY, BIWEEKLY, MONTHLY, QUARTERLY, YEARLY, CUSTOM
  frequency_interval INTEGER DEFAULT 1, -- For CUSTOM: every X days/weeks/months

  -- Day specification
  day_of_week INTEGER, -- 0-6 for WEEKLY (0=Sunday)
  day_of_month INTEGER, -- 1-31 for MONTHLY
  month_of_year INTEGER, -- 1-12 for YEARLY
  end_of_month_handling VARCHAR(20) DEFAULT 'LAST_DAY', -- LAST_DAY, SKIP, FIRST_OF_NEXT

  -- Weekend/holiday handling
  skip_weekends BOOLEAN DEFAULT FALSE,
  skip_holidays BOOLEAN DEFAULT FALSE,
  weekend_adjustment VARCHAR(20) DEFAULT 'PREVIOUS', -- PREVIOUS, NEXT, NONE

  -- Date range
  start_date DATE NOT NULL,
  end_date DATE, -- NULL = no end date
  next_run_date DATE NOT NULL,
  last_run_date DATE,

  -- Generation options
  auto_post BOOLEAN DEFAULT FALSE, -- TRUE = auto-post, FALSE = create as draft
  max_occurrences INTEGER, -- NULL = unlimited
  occurrences_count INTEGER DEFAULT 0,

  -- Variable defaults (for template variables)
  default_variable_values JSONB DEFAULT '{}',

  -- Status
  status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE', -- ACTIVE, PAUSED, COMPLETED, EXPIRED, ERROR
  paused_at TIMESTAMPTZ,
  paused_by UUID REFERENCES users(id),
  error_message TEXT,
  retry_count INTEGER DEFAULT 0,
  max_retries INTEGER DEFAULT 3,

  -- Notifications
  notify_on_success BOOLEAN DEFAULT TRUE,
  notify_on_failure BOOLEAN DEFAULT TRUE,
  notification_emails TEXT[], -- Additional emails beyond schedule owner

  -- Audit
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES users(id),
  updated_by UUID REFERENCES users(id),

  UNIQUE(organization_id, schedule_code)
);

-- Schedule execution history
CREATE TABLE schedule_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  schedule_id UUID NOT NULL REFERENCES recurring_entry_schedules(id),

  execution_date DATE NOT NULL,
  scheduled_date DATE NOT NULL, -- The original scheduled date
  execution_type VARCHAR(20) NOT NULL, -- AUTOMATIC, MANUAL, BATCH, MISSED

  status VARCHAR(20) NOT NULL, -- SUCCESS, FAILED, SKIPPED
  error_message TEXT,

  -- Generated entry reference
  journal_entry_id UUID REFERENCES journal_entries(id),

  -- Execution details
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  execution_time_ms INTEGER,

  -- Variable values used
  variable_values_used JSONB,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Holiday calendar for skip calculations
CREATE TABLE holiday_calendar (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),

  holiday_date DATE NOT NULL,
  holiday_name VARCHAR(255) NOT NULL,
  is_banking_holiday BOOLEAN DEFAULT TRUE,
  country_code CHAR(2) DEFAULT 'PL',

  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES users(id),

  UNIQUE(organization_id, holiday_date)
);

-- Indexes
CREATE INDEX idx_schedules_org ON recurring_entry_schedules(organization_id);
CREATE INDEX idx_schedules_status ON recurring_entry_schedules(status);
CREATE INDEX idx_schedules_next_run ON recurring_entry_schedules(next_run_date) WHERE status = 'ACTIVE';
CREATE INDEX idx_executions_schedule ON schedule_executions(schedule_id);
CREATE INDEX idx_executions_date ON schedule_executions(execution_date);
CREATE INDEX idx_holidays_org_date ON holiday_calendar(organization_id, holiday_date);

-- RLS Policies
ALTER TABLE recurring_entry_schedules ENABLE ROW LEVEL SECURITY;
ALTER TABLE schedule_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE holiday_calendar ENABLE ROW LEVEL SECURITY;

CREATE POLICY schedules_org_isolation ON recurring_entry_schedules
  USING (organization_id = current_setting('app.current_org_id')::UUID);

CREATE POLICY executions_isolation ON schedule_executions
  USING (schedule_id IN (
    SELECT id FROM recurring_entry_schedules
    WHERE organization_id = current_setting('app.current_org_id')::UUID
  ));

CREATE POLICY holidays_org_isolation ON holiday_calendar
  USING (organization_id = current_setting('app.current_org_id')::UUID);
```

### Zod Validation Schemas

```typescript
import { z } from 'zod';

// Enums
export const FrequencyEnum = z.enum([
  'DAILY',
  'WEEKLY',
  'BIWEEKLY',
  'MONTHLY',
  'QUARTERLY',
  'YEARLY',
  'CUSTOM'
]);

export const ScheduleStatusEnum = z.enum([
  'ACTIVE',
  'PAUSED',
  'COMPLETED',
  'EXPIRED',
  'ERROR'
]);

export const EndOfMonthHandlingEnum = z.enum([
  'LAST_DAY',  // Use last day of month
  'SKIP',      // Skip if day doesn't exist
  'FIRST_OF_NEXT' // Use first day of next month
]);

export const WeekendAdjustmentEnum = z.enum([
  'PREVIOUS', // Move to previous business day
  'NEXT',     // Move to next business day
  'NONE'      // Don't adjust
]);

export const ExecutionTypeEnum = z.enum([
  'AUTOMATIC',
  'MANUAL',
  'BATCH',
  'MISSED'
]);

// Create schedule input
export const CreateScheduleInput = z.object({
  scheduleName: z.string().min(1).max(255),
  description: z.string().max(2000).optional(),
  templateId: z.string().uuid(),

  // Frequency configuration
  frequency: FrequencyEnum,
  frequencyInterval: z.number().int().positive().default(1),

  // Day specification
  dayOfWeek: z.number().int().min(0).max(6).optional(), // For WEEKLY
  dayOfMonth: z.number().int().min(1).max(31).optional(), // For MONTHLY
  monthOfYear: z.number().int().min(1).max(12).optional(), // For YEARLY
  endOfMonthHandling: EndOfMonthHandlingEnum.default('LAST_DAY'),

  // Weekend/holiday handling
  skipWeekends: z.boolean().default(false),
  skipHolidays: z.boolean().default(false),
  weekendAdjustment: WeekendAdjustmentEnum.default('PREVIOUS'),

  // Date range
  startDate: z.coerce.date(),
  endDate: z.coerce.date().optional(),
  maxOccurrences: z.number().int().positive().optional(),

  // Generation options
  autoPost: z.boolean().default(false),
  defaultVariableValues: z.record(z.string(), z.any()).optional(),

  // Notifications
  notifyOnSuccess: z.boolean().default(true),
  notifyOnFailure: z.boolean().default(true),
  notificationEmails: z.array(z.string().email()).optional(),
}).refine(
  (data) => {
    if (data.frequency === 'WEEKLY' && data.dayOfWeek === undefined) {
      return false;
    }
    if ((data.frequency === 'MONTHLY' || data.frequency === 'QUARTERLY') && data.dayOfMonth === undefined) {
      return false;
    }
    if (data.frequency === 'YEARLY' && (data.dayOfMonth === undefined || data.monthOfYear === undefined)) {
      return false;
    }
    return true;
  },
  { message: 'Day specification required for selected frequency' }
).refine(
  (data) => {
    if (data.endDate && data.endDate <= data.startDate) {
      return false;
    }
    return true;
  },
  { message: 'End date must be after start date' }
);

// Update schedule input
export const UpdateScheduleInput = z.object({
  scheduleId: z.string().uuid(),
  scheduleName: z.string().min(1).max(255).optional(),
  description: z.string().max(2000).optional(),

  frequency: FrequencyEnum.optional(),
  frequencyInterval: z.number().int().positive().optional(),
  dayOfWeek: z.number().int().min(0).max(6).optional(),
  dayOfMonth: z.number().int().min(1).max(31).optional(),
  monthOfYear: z.number().int().min(1).max(12).optional(),
  endOfMonthHandling: EndOfMonthHandlingEnum.optional(),

  skipWeekends: z.boolean().optional(),
  skipHolidays: z.boolean().optional(),
  weekendAdjustment: WeekendAdjustmentEnum.optional(),

  endDate: z.coerce.date().nullable().optional(),
  maxOccurrences: z.number().int().positive().nullable().optional(),

  autoPost: z.boolean().optional(),
  defaultVariableValues: z.record(z.string(), z.any()).optional(),

  notifyOnSuccess: z.boolean().optional(),
  notifyOnFailure: z.boolean().optional(),
  notificationEmails: z.array(z.string().email()).optional(),
});

// Manual generation input
export const ManualGenerateInput = z.object({
  scheduleId: z.string().uuid(),
  entryDate: z.coerce.date().optional(), // Defaults to today
  variableOverrides: z.record(z.string(), z.any()).optional(),
  autoPost: z.boolean().optional(), // Override schedule setting
});

// Batch generate missed entries
export const BatchGenerateMissedInput = z.object({
  scheduleId: z.string().uuid(),
  fromDate: z.coerce.date(),
  toDate: z.coerce.date(),
  createAsDraft: z.boolean().default(true), // Always draft for review
});

// List schedules filter
export const ListSchedulesInput = z.object({
  status: ScheduleStatusEnum.optional(),
  templateId: z.string().uuid().optional(),
  search: z.string().max(100).optional(),
  upcomingDays: z.number().int().min(1).max(365).optional(),
  limit: z.number().int().min(1).max(100).default(50),
  offset: z.number().int().min(0).default(0),
});

// Preview upcoming entries
export const PreviewUpcomingInput = z.object({
  scheduleId: z.string().uuid().optional(), // If not provided, show all
  fromDate: z.coerce.date().optional(), // Default: today
  toDate: z.coerce.date(), // Required
});

// Add holiday
export const AddHolidayInput = z.object({
  holidayDate: z.coerce.date(),
  holidayName: z.string().min(1).max(255),
  isBankingHoliday: z.boolean().default(true),
  countryCode: z.string().length(2).default('PL'),
});
```

### tRPC Router Implementation

```typescript
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { createTRPCRouter, protectedProcedure } from '../trpc';
import {
  CreateScheduleInput,
  UpdateScheduleInput,
  ManualGenerateInput,
  BatchGenerateMissedInput,
  ListSchedulesInput,
  PreviewUpcomingInput,
  AddHolidayInput,
  ScheduleStatusEnum,
} from './schemas';
import {
  addDays,
  addWeeks,
  addMonths,
  addYears,
  setDate,
  lastDayOfMonth,
  isWeekend,
  isSameDay,
  startOfDay,
  endOfDay,
} from 'date-fns';

export const recurringEntryRouter = createTRPCRouter({

  // Create recurring schedule
  create: protectedProcedure
    .input(CreateScheduleInput)
    .mutation(async ({ ctx, input }) => {
      const { db, session, auditLog } = ctx;
      const organizationId = session.user.organizationId;

      // Verify template exists
      const template = await db.query.journalEntryTemplates.findFirst({
        where: eq(journalEntryTemplates.id, input.templateId),
      });

      if (!template) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Template not found',
        });
      }

      // Generate schedule code
      const scheduleCode = await generateScheduleCode(db, organizationId);

      // Calculate first run date
      const nextRunDate = await calculateNextRunDate(
        db,
        organizationId,
        input.startDate,
        input
      );

      const [schedule] = await db.insert(recurringEntrySchedules).values({
        organizationId,
        scheduleCode,
        scheduleName: input.scheduleName,
        description: input.description,
        templateId: input.templateId,

        frequency: input.frequency,
        frequencyInterval: input.frequencyInterval,
        dayOfWeek: input.dayOfWeek,
        dayOfMonth: input.dayOfMonth,
        monthOfYear: input.monthOfYear,
        endOfMonthHandling: input.endOfMonthHandling,

        skipWeekends: input.skipWeekends,
        skipHolidays: input.skipHolidays,
        weekendAdjustment: input.weekendAdjustment,

        startDate: input.startDate,
        endDate: input.endDate,
        nextRunDate,
        maxOccurrences: input.maxOccurrences,

        autoPost: input.autoPost,
        defaultVariableValues: input.defaultVariableValues || {},

        notifyOnSuccess: input.notifyOnSuccess,
        notifyOnFailure: input.notifyOnFailure,
        notificationEmails: input.notificationEmails,

        status: 'ACTIVE',
        createdBy: session.user.id,
      }).returning();

      await auditLog.record({
        action: 'RECURRING_SCHEDULE_CREATED',
        entityType: 'recurring_entry_schedule',
        entityId: schedule.id,
        details: {
          scheduleCode,
          templateId: input.templateId,
          frequency: input.frequency,
          nextRunDate,
        },
      });

      return schedule;
    }),

  // Update schedule
  update: protectedProcedure
    .input(UpdateScheduleInput)
    .mutation(async ({ ctx, input }) => {
      const { db, session, auditLog } = ctx;
      const { scheduleId, ...updateData } = input;

      const existing = await db.query.recurringEntrySchedules.findFirst({
        where: eq(recurringEntrySchedules.id, scheduleId),
      });

      if (!existing) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Schedule not found',
        });
      }

      // Recalculate next run date if frequency changed
      let nextRunDate = existing.nextRunDate;
      if (updateData.frequency || updateData.dayOfMonth || updateData.dayOfWeek) {
        const config = { ...existing, ...updateData };
        nextRunDate = await calculateNextRunDate(
          db,
          session.user.organizationId,
          existing.lastRunDate || existing.startDate,
          config
        );
      }

      const [updated] = await db.update(recurringEntrySchedules)
        .set({
          ...updateData,
          nextRunDate,
          updatedAt: new Date(),
          updatedBy: session.user.id,
        })
        .where(eq(recurringEntrySchedules.id, scheduleId))
        .returning();

      await auditLog.record({
        action: 'RECURRING_SCHEDULE_UPDATED',
        entityType: 'recurring_entry_schedule',
        entityId: scheduleId,
        details: { changes: Object.keys(updateData) },
      });

      return updated;
    }),

  // Pause schedule
  pause: protectedProcedure
    .input(z.object({ scheduleId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { db, session, auditLog } = ctx;

      const [paused] = await db.update(recurringEntrySchedules)
        .set({
          status: 'PAUSED',
          pausedAt: new Date(),
          pausedBy: session.user.id,
          updatedAt: new Date(),
          updatedBy: session.user.id,
        })
        .where(eq(recurringEntrySchedules.id, input.scheduleId))
        .returning();

      await auditLog.record({
        action: 'RECURRING_SCHEDULE_PAUSED',
        entityType: 'recurring_entry_schedule',
        entityId: input.scheduleId,
      });

      return paused;
    }),

  // Resume schedule
  resume: protectedProcedure
    .input(z.object({
      scheduleId: z.string().uuid(),
      generateMissed: z.boolean().default(false),
    }))
    .mutation(async ({ ctx, input }) => {
      const { db, session, auditLog } = ctx;

      const schedule = await db.query.recurringEntrySchedules.findFirst({
        where: eq(recurringEntrySchedules.id, input.scheduleId),
      });

      if (!schedule) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Schedule not found',
        });
      }

      // Calculate missed dates if needed
      let missedEntries = [];
      if (input.generateMissed && schedule.pausedAt) {
        missedEntries = await calculateMissedDates(
          db,
          session.user.organizationId,
          schedule,
          schedule.pausedAt,
          new Date()
        );
      }

      // Calculate new next run date
      const nextRunDate = await calculateNextRunDate(
        db,
        session.user.organizationId,
        new Date(),
        schedule
      );

      const [resumed] = await db.update(recurringEntrySchedules)
        .set({
          status: 'ACTIVE',
          pausedAt: null,
          pausedBy: null,
          nextRunDate,
          errorMessage: null,
          retryCount: 0,
          updatedAt: new Date(),
          updatedBy: session.user.id,
        })
        .where(eq(recurringEntrySchedules.id, input.scheduleId))
        .returning();

      // Generate missed entries
      if (missedEntries.length > 0) {
        for (const missedDate of missedEntries) {
          await ctx.caller.recurringEntry.manualGenerate({
            scheduleId: input.scheduleId,
            entryDate: missedDate,
          });
        }
      }

      await auditLog.record({
        action: 'RECURRING_SCHEDULE_RESUMED',
        entityType: 'recurring_entry_schedule',
        entityId: input.scheduleId,
        details: { missedEntriesGenerated: missedEntries.length },
      });

      return {
        schedule: resumed,
        missedEntriesGenerated: missedEntries.length,
      };
    }),

  // Delete (archive) schedule
  delete: protectedProcedure
    .input(z.object({ scheduleId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { db, session, auditLog } = ctx;

      const [deleted] = await db.update(recurringEntrySchedules)
        .set({
          status: 'COMPLETED',
          updatedAt: new Date(),
          updatedBy: session.user.id,
        })
        .where(eq(recurringEntrySchedules.id, input.scheduleId))
        .returning();

      await auditLog.record({
        action: 'RECURRING_SCHEDULE_DELETED',
        entityType: 'recurring_entry_schedule',
        entityId: input.scheduleId,
      });

      return deleted;
    }),

  // Manual generation
  manualGenerate: protectedProcedure
    .input(ManualGenerateInput)
    .mutation(async ({ ctx, input }) => {
      const { db, session, auditLog } = ctx;
      const startTime = Date.now();

      const schedule = await db.query.recurringEntrySchedules.findFirst({
        where: eq(recurringEntrySchedules.id, input.scheduleId),
        with: { template: true },
      });

      if (!schedule) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Schedule not found',
        });
      }

      const entryDate = input.entryDate || new Date();
      const variableValues = {
        ...(schedule.defaultVariableValues || {}),
        ...(input.variableOverrides || {}),
      };

      // Create execution record
      const [execution] = await db.insert(scheduleExecutions).values({
        scheduleId: input.scheduleId,
        executionDate: entryDate,
        scheduledDate: entryDate,
        executionType: 'MANUAL',
        status: 'SUCCESS', // Will be updated if fails
        startedAt: new Date(),
        variableValuesUsed: variableValues,
      }).returning();

      try {
        // Generate entry using template
        const entry = await ctx.caller.template.generateEntry({
          templateId: schedule.templateId,
          entryDate,
          variableValues,
        });

        // Auto-post if configured
        const shouldAutoPost = input.autoPost ?? schedule.autoPost;
        if (shouldAutoPost) {
          await ctx.caller.journalEntry.post({ entryId: entry.id });
        }

        // Update execution record
        await db.update(scheduleExecutions)
          .set({
            status: 'SUCCESS',
            journalEntryId: entry.id,
            completedAt: new Date(),
            executionTimeMs: Date.now() - startTime,
          })
          .where(eq(scheduleExecutions.id, execution.id));

        // Update schedule statistics
        await db.update(recurringEntrySchedules)
          .set({
            occurrencesCount: schedule.occurrencesCount + 1,
            lastRunDate: entryDate,
          })
          .where(eq(recurringEntrySchedules.id, input.scheduleId));

        // Send notification
        if (schedule.notifyOnSuccess) {
          await sendNotification(ctx, schedule, 'success', entry);
        }

        await auditLog.record({
          action: 'RECURRING_ENTRY_GENERATED',
          entityType: 'journal_entry',
          entityId: entry.id,
          details: {
            scheduleId: input.scheduleId,
            executionType: 'MANUAL',
          },
        });

        return entry;

      } catch (error) {
        // Update execution as failed
        await db.update(scheduleExecutions)
          .set({
            status: 'FAILED',
            errorMessage: error instanceof Error ? error.message : 'Unknown error',
            completedAt: new Date(),
            executionTimeMs: Date.now() - startTime,
          })
          .where(eq(scheduleExecutions.id, execution.id));

        // Send failure notification
        if (schedule.notifyOnFailure) {
          await sendNotification(ctx, schedule, 'failure', null, error);
        }

        throw error;
      }
    }),

  // Batch generate missed entries
  batchGenerateMissed: protectedProcedure
    .input(BatchGenerateMissedInput)
    .mutation(async ({ ctx, input }) => {
      const schedule = await ctx.db.query.recurringEntrySchedules.findFirst({
        where: eq(recurringEntrySchedules.id, input.scheduleId),
      });

      if (!schedule) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Schedule not found',
        });
      }

      // Calculate all dates in range
      const dates = await calculateMissedDates(
        ctx.db,
        ctx.session.user.organizationId,
        schedule,
        input.fromDate,
        input.toDate
      );

      const results = [];

      for (const date of dates) {
        try {
          const entry = await ctx.caller.recurringEntry.manualGenerate({
            scheduleId: input.scheduleId,
            entryDate: date,
            autoPost: !input.createAsDraft, // Create as draft for review
          });
          results.push({ date, success: true, entryId: entry.id });
        } catch (error) {
          results.push({
            date,
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
          });
        }
      }

      return {
        total: dates.length,
        successful: results.filter(r => r.success).length,
        failed: results.filter(r => !r.success).length,
        results,
      };
    }),

  // List schedules
  list: protectedProcedure
    .input(ListSchedulesInput)
    .query(async ({ ctx, input }) => {
      const { db, session } = ctx;
      const organizationId = session.user.organizationId;

      const conditions = [
        eq(recurringEntrySchedules.organizationId, organizationId),
      ];

      if (input.status) {
        conditions.push(eq(recurringEntrySchedules.status, input.status));
      }

      if (input.templateId) {
        conditions.push(eq(recurringEntrySchedules.templateId, input.templateId));
      }

      if (input.search) {
        conditions.push(
          or(
            ilike(recurringEntrySchedules.scheduleName, `%${input.search}%`),
            ilike(recurringEntrySchedules.scheduleCode, `%${input.search}%`)
          )
        );
      }

      if (input.upcomingDays) {
        const futureDate = addDays(new Date(), input.upcomingDays);
        conditions.push(
          and(
            eq(recurringEntrySchedules.status, 'ACTIVE'),
            lte(recurringEntrySchedules.nextRunDate, futureDate)
          )
        );
      }

      const schedules = await db.select()
        .from(recurringEntrySchedules)
        .where(and(...conditions))
        .leftJoin(journalEntryTemplates, eq(journalEntryTemplates.id, recurringEntrySchedules.templateId))
        .orderBy(asc(recurringEntrySchedules.nextRunDate))
        .limit(input.limit)
        .offset(input.offset);

      const total = await db.select({ count: count() })
        .from(recurringEntrySchedules)
        .where(and(...conditions));

      return {
        schedules,
        total: total[0].count,
        hasMore: input.offset + schedules.length < total[0].count,
      };
    }),

  // Get schedule by ID
  getById: protectedProcedure
    .input(z.object({ scheduleId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const schedule = await ctx.db.query.recurringEntrySchedules.findFirst({
        where: eq(recurringEntrySchedules.id, input.scheduleId),
        with: {
          template: true,
          createdByUser: { columns: { id: true, name: true } },
        },
      });

      if (!schedule) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Schedule not found',
        });
      }

      return schedule;
    }),

  // Get execution history
  getExecutionHistory: protectedProcedure
    .input(z.object({
      scheduleId: z.string().uuid(),
      limit: z.number().int().min(1).max(100).default(20),
      offset: z.number().int().min(0).default(0),
    }))
    .query(async ({ ctx, input }) => {
      const executions = await ctx.db.query.scheduleExecutions.findMany({
        where: eq(scheduleExecutions.scheduleId, input.scheduleId),
        orderBy: (exec, { desc }) => [desc(exec.executionDate)],
        limit: input.limit,
        offset: input.offset,
        with: {
          journalEntry: { columns: { id: true, entryNumber: true, status: true } },
        },
      });

      return executions;
    }),

  // Preview upcoming entries
  previewUpcoming: protectedProcedure
    .input(PreviewUpcomingInput)
    .query(async ({ ctx, input }) => {
      const { db, session } = ctx;
      const organizationId = session.user.organizationId;

      const fromDate = input.fromDate || new Date();
      const toDate = input.toDate;

      // Get active schedules
      const conditions = [
        eq(recurringEntrySchedules.organizationId, organizationId),
        eq(recurringEntrySchedules.status, 'ACTIVE'),
      ];

      if (input.scheduleId) {
        conditions.push(eq(recurringEntrySchedules.id, input.scheduleId));
      }

      const schedules = await db.query.recurringEntrySchedules.findMany({
        where: and(...conditions),
        with: { template: true },
      });

      const upcoming = [];

      for (const schedule of schedules) {
        const dates = await calculateUpcomingDates(
          db,
          organizationId,
          schedule,
          fromDate,
          toDate
        );

        for (const date of dates) {
          upcoming.push({
            scheduleId: schedule.id,
            scheduleName: schedule.scheduleName,
            templateName: schedule.template.templateName,
            scheduledDate: date,
            autoPost: schedule.autoPost,
          });
        }
      }

      // Sort by date
      upcoming.sort((a, b) => a.scheduledDate.getTime() - b.scheduledDate.getTime());

      return upcoming;
    }),

  // Holiday management
  addHoliday: protectedProcedure
    .input(AddHolidayInput)
    .mutation(async ({ ctx, input }) => {
      const [holiday] = await ctx.db.insert(holidayCalendar).values({
        organizationId: ctx.session.user.organizationId,
        holidayDate: input.holidayDate,
        holidayName: input.holidayName,
        isBankingHoliday: input.isBankingHoliday,
        countryCode: input.countryCode,
        createdBy: ctx.session.user.id,
      }).returning();

      return holiday;
    }),

  listHolidays: protectedProcedure
    .input(z.object({
      year: z.number().int().min(2000).max(2100),
    }))
    .query(async ({ ctx, input }) => {
      const startDate = new Date(input.year, 0, 1);
      const endDate = new Date(input.year, 11, 31);

      return await ctx.db.query.holidayCalendar.findMany({
        where: and(
          eq(holidayCalendar.organizationId, ctx.session.user.organizationId),
          gte(holidayCalendar.holidayDate, startDate),
          lte(holidayCalendar.holidayDate, endDate)
        ),
        orderBy: (h, { asc }) => [asc(h.holidayDate)],
      });
    }),
});

// Helper functions
async function generateScheduleCode(db: any, organizationId: string): Promise<string> {
  const year = new Date().getFullYear();
  const prefix = `REC-${year}-`;

  const lastSchedule = await db.query.recurringEntrySchedules.findFirst({
    where: and(
      eq(recurringEntrySchedules.organizationId, organizationId),
      like(recurringEntrySchedules.scheduleCode, `${prefix}%`)
    ),
    orderBy: (s, { desc }) => [desc(s.scheduleCode)],
  });

  let nextNumber = 1;
  if (lastSchedule) {
    const lastNumber = parseInt(lastSchedule.scheduleCode.replace(prefix, ''));
    nextNumber = lastNumber + 1;
  }

  return `${prefix}${String(nextNumber).padStart(4, '0')}`;
}

async function calculateNextRunDate(
  db: any,
  organizationId: string,
  fromDate: Date,
  config: any
): Promise<Date> {
  let nextDate = new Date(fromDate);

  // Calculate base next date based on frequency
  switch (config.frequency) {
    case 'DAILY':
      nextDate = addDays(nextDate, config.frequencyInterval || 1);
      break;
    case 'WEEKLY':
      nextDate = addWeeks(nextDate, config.frequencyInterval || 1);
      // Adjust to specific day of week
      if (config.dayOfWeek !== undefined) {
        const currentDay = nextDate.getDay();
        const diff = (config.dayOfWeek - currentDay + 7) % 7;
        nextDate = addDays(nextDate, diff || 7);
      }
      break;
    case 'BIWEEKLY':
      nextDate = addWeeks(nextDate, 2);
      if (config.dayOfWeek !== undefined) {
        const currentDay = nextDate.getDay();
        const diff = (config.dayOfWeek - currentDay + 7) % 7;
        nextDate = addDays(nextDate, diff);
      }
      break;
    case 'MONTHLY':
      nextDate = addMonths(nextDate, config.frequencyInterval || 1);
      nextDate = adjustDayOfMonth(nextDate, config.dayOfMonth, config.endOfMonthHandling);
      break;
    case 'QUARTERLY':
      nextDate = addMonths(nextDate, 3);
      nextDate = adjustDayOfMonth(nextDate, config.dayOfMonth, config.endOfMonthHandling);
      break;
    case 'YEARLY':
      nextDate = addYears(nextDate, 1);
      nextDate = new Date(nextDate.getFullYear(), config.monthOfYear - 1, 1);
      nextDate = adjustDayOfMonth(nextDate, config.dayOfMonth, config.endOfMonthHandling);
      break;
    case 'CUSTOM':
      // Custom interval in days
      nextDate = addDays(nextDate, config.frequencyInterval || 1);
      break;
  }

  // Adjust for weekends and holidays
  if (config.skipWeekends || config.skipHolidays) {
    nextDate = await adjustForNonBusinessDay(
      db,
      organizationId,
      nextDate,
      config.skipWeekends,
      config.skipHolidays,
      config.weekendAdjustment
    );
  }

  return startOfDay(nextDate);
}

function adjustDayOfMonth(date: Date, targetDay: number, handling: string): Date {
  const lastDay = lastDayOfMonth(date).getDate();

  if (targetDay > lastDay) {
    switch (handling) {
      case 'LAST_DAY':
        return lastDayOfMonth(date);
      case 'SKIP':
        return addMonths(adjustDayOfMonth(addMonths(date, 1), targetDay, handling), 0);
      case 'FIRST_OF_NEXT':
        return addMonths(setDate(date, 1), 1);
      default:
        return lastDayOfMonth(date);
    }
  }

  return setDate(date, targetDay);
}

async function adjustForNonBusinessDay(
  db: any,
  organizationId: string,
  date: Date,
  skipWeekends: boolean,
  skipHolidays: boolean,
  adjustment: string
): Promise<Date> {
  let adjusted = new Date(date);
  const direction = adjustment === 'NEXT' ? 1 : -1;
  let attempts = 0;
  const maxAttempts = 10;

  while (attempts < maxAttempts) {
    const isNonBusinessDay = (skipWeekends && isWeekend(adjusted)) ||
      (skipHolidays && await isHoliday(db, organizationId, adjusted));

    if (!isNonBusinessDay) {
      break;
    }

    adjusted = addDays(adjusted, direction);
    attempts++;
  }

  return adjusted;
}

async function isHoliday(db: any, organizationId: string, date: Date): Promise<boolean> {
  const holiday = await db.query.holidayCalendar.findFirst({
    where: and(
      eq(holidayCalendar.organizationId, organizationId),
      eq(holidayCalendar.holidayDate, startOfDay(date))
    ),
  });

  return !!holiday;
}

async function calculateMissedDates(
  db: any,
  organizationId: string,
  schedule: any,
  fromDate: Date,
  toDate: Date
): Promise<Date[]> {
  const dates: Date[] = [];
  let currentDate = new Date(fromDate);

  while (currentDate <= toDate) {
    const nextDate = await calculateNextRunDate(db, organizationId, currentDate, schedule);

    if (nextDate > toDate) {
      break;
    }

    // Check if this date was already executed
    const execution = await db.query.scheduleExecutions.findFirst({
      where: and(
        eq(scheduleExecutions.scheduleId, schedule.id),
        eq(scheduleExecutions.scheduledDate, startOfDay(nextDate)),
        eq(scheduleExecutions.status, 'SUCCESS')
      ),
    });

    if (!execution) {
      dates.push(nextDate);
    }

    currentDate = nextDate;
  }

  return dates;
}

async function calculateUpcomingDates(
  db: any,
  organizationId: string,
  schedule: any,
  fromDate: Date,
  toDate: Date
): Promise<Date[]> {
  const dates: Date[] = [];
  let currentDate = schedule.nextRunDate ? new Date(schedule.nextRunDate) : new Date(fromDate);

  while (currentDate <= toDate) {
    if (currentDate >= fromDate) {
      dates.push(new Date(currentDate));
    }

    currentDate = await calculateNextRunDate(db, organizationId, currentDate, schedule);

    // Safety check for max occurrences
    if (schedule.maxOccurrences && dates.length >= schedule.maxOccurrences - schedule.occurrencesCount) {
      break;
    }
  }

  return dates;
}

async function sendNotification(
  ctx: any,
  schedule: any,
  type: 'success' | 'failure',
  entry?: any,
  error?: Error
): Promise<void> {
  const { notificationService } = ctx;

  const recipients = [schedule.createdBy];
  if (schedule.notificationEmails) {
    recipients.push(...schedule.notificationEmails);
  }

  if (type === 'success') {
    await notificationService.send({
      type: 'RECURRING_ENTRY_SUCCESS',
      recipients,
      data: {
        scheduleName: schedule.scheduleName,
        entryNumber: entry?.entryNumber,
        entryId: entry?.id,
      },
    });
  } else {
    await notificationService.send({
      type: 'RECURRING_ENTRY_FAILURE',
      recipients,
      priority: 'high',
      data: {
        scheduleName: schedule.scheduleName,
        errorMessage: error?.message,
      },
    });
  }
}

// Scheduler job (runs via cron)
export async function processRecurringSchedules(db: any, notificationService: any) {
  const today = startOfDay(new Date());

  // Get all active schedules due today
  const dueSchedules = await db.query.recurringEntrySchedules.findMany({
    where: and(
      eq(recurringEntrySchedules.status, 'ACTIVE'),
      lte(recurringEntrySchedules.nextRunDate, today)
    ),
    with: { template: true },
  });

  const results = [];

  for (const schedule of dueSchedules) {
    try {
      // Check if already executed today
      const existingExecution = await db.query.scheduleExecutions.findFirst({
        where: and(
          eq(scheduleExecutions.scheduleId, schedule.id),
          eq(scheduleExecutions.scheduledDate, today),
          eq(scheduleExecutions.executionType, 'AUTOMATIC')
        ),
      });

      if (existingExecution) {
        continue; // Already processed
      }

      // Generate entry
      const entry = await generateRecurringEntry(db, schedule, today);

      // Update next run date
      const nextRunDate = await calculateNextRunDate(
        db,
        schedule.organizationId,
        today,
        schedule
      );

      // Check if schedule should be marked as completed
      let newStatus = 'ACTIVE';
      if (schedule.endDate && nextRunDate > schedule.endDate) {
        newStatus = 'EXPIRED';
      }
      if (schedule.maxOccurrences && schedule.occurrencesCount + 1 >= schedule.maxOccurrences) {
        newStatus = 'COMPLETED';
      }

      await db.update(recurringEntrySchedules)
        .set({
          nextRunDate,
          lastRunDate: today,
          occurrencesCount: schedule.occurrencesCount + 1,
          status: newStatus,
          errorMessage: null,
          retryCount: 0,
          updatedAt: new Date(),
        })
        .where(eq(recurringEntrySchedules.id, schedule.id));

      results.push({
        scheduleId: schedule.id,
        status: 'success',
        entryId: entry.id,
      });

    } catch (error) {
      // Update retry count
      const newRetryCount = schedule.retryCount + 1;
      const newStatus = newRetryCount >= schedule.maxRetries ? 'ERROR' : 'ACTIVE';

      await db.update(recurringEntrySchedules)
        .set({
          retryCount: newRetryCount,
          status: newStatus,
          errorMessage: error instanceof Error ? error.message : 'Unknown error',
          updatedAt: new Date(),
        })
        .where(eq(recurringEntrySchedules.id, schedule.id));

      results.push({
        scheduleId: schedule.id,
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
      });

      // Send failure notification
      if (schedule.notifyOnFailure) {
        await sendNotification({ notificationService }, schedule, 'failure', null, error as Error);
      }
    }
  }

  return {
    processed: results.length,
    successful: results.filter(r => r.status === 'success').length,
    failed: results.filter(r => r.status === 'failed').length,
    results,
  };
}
```

---

## Test Specifications

### Unit Tests

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { recurringEntryRouter, processRecurringSchedules } from './recurring-entry.router';
import { createTestContext, createMockSchedule, createMockTemplate } from '@/test/utils';

describe('Recurring Entry Router', () => {
  let ctx: ReturnType<typeof createTestContext>;

  beforeEach(() => {
    ctx = createTestContext();
    vi.useFakeTimers();
  });

  describe('create', () => {
    it('should create monthly schedule', async () => {
      const template = await createMockTemplate(ctx.db);

      const result = await recurringEntryRouter.create({
        ctx,
        input: {
          scheduleName: 'Monthly Depreciation',
          templateId: template.id,
          frequency: 'MONTHLY',
          dayOfMonth: 31,
          startDate: new Date('2024-01-01'),
          autoPost: false,
        },
      });

      expect(result.status).toBe('ACTIVE');
      expect(result.nextRunDate).toEqual(new Date('2024-01-31'));
    });

    it('should create weekly schedule on specific day', async () => {
      const template = await createMockTemplate(ctx.db);

      const result = await recurringEntryRouter.create({
        ctx,
        input: {
          scheduleName: 'Weekly Payroll',
          templateId: template.id,
          frequency: 'WEEKLY',
          dayOfWeek: 5, // Friday
          startDate: new Date('2024-01-01'),
        },
      });

      expect(result.frequency).toBe('WEEKLY');
      expect(result.dayOfWeek).toBe(5);
    });

    it('should handle skip weekends option', async () => {
      const template = await createMockTemplate(ctx.db);

      const result = await recurringEntryRouter.create({
        ctx,
        input: {
          scheduleName: 'Monthly with Weekend Skip',
          templateId: template.id,
          frequency: 'MONTHLY',
          dayOfMonth: 25, // If Saturday
          skipWeekends: true,
          weekendAdjustment: 'PREVIOUS',
          startDate: new Date('2024-01-01'),
        },
      });

      expect(result.skipWeekends).toBe(true);
      expect(result.weekendAdjustment).toBe('PREVIOUS');
    });
  });

  describe('manualGenerate', () => {
    it('should generate entry manually', async () => {
      const schedule = await createMockSchedule(ctx.db);

      const entry = await recurringEntryRouter.manualGenerate({
        ctx,
        input: {
          scheduleId: schedule.id,
          entryDate: new Date('2024-02-15'),
        },
      });

      expect(entry).toBeDefined();
      expect(entry.status).toBe('DRAFT');
    });

    it('should auto-post when configured', async () => {
      const schedule = await createMockSchedule(ctx.db, { autoPost: true });

      const entry = await recurringEntryRouter.manualGenerate({
        ctx,
        input: {
          scheduleId: schedule.id,
        },
      });

      expect(entry.status).toBe('POSTED');
    });

    it('should use variable overrides', async () => {
      const schedule = await createMockSchedule(ctx.db, {
        defaultVariableValues: { amount: 1000 },
      });

      const entry = await recurringEntryRouter.manualGenerate({
        ctx,
        input: {
          scheduleId: schedule.id,
          variableOverrides: { amount: 1500 },
        },
      });

      expect(entry.lines[0].debitAmount).toBe('1500.00');
    });
  });

  describe('pause/resume', () => {
    it('should pause active schedule', async () => {
      const schedule = await createMockSchedule(ctx.db);

      const paused = await recurringEntryRouter.pause({
        ctx,
        input: { scheduleId: schedule.id },
      });

      expect(paused.status).toBe('PAUSED');
      expect(paused.pausedAt).toBeDefined();
    });

    it('should resume and generate missed entries', async () => {
      vi.setSystemTime(new Date('2024-03-01'));

      const schedule = await createMockSchedule(ctx.db, {
        status: 'PAUSED',
        pausedAt: new Date('2024-01-01'),
        nextRunDate: new Date('2024-01-31'),
      });

      const result = await recurringEntryRouter.resume({
        ctx,
        input: {
          scheduleId: schedule.id,
          generateMissed: true,
        },
      });

      expect(result.schedule.status).toBe('ACTIVE');
      expect(result.missedEntriesGenerated).toBeGreaterThan(0);
    });
  });

  describe('previewUpcoming', () => {
    it('should show upcoming entries for next 30 days', async () => {
      vi.setSystemTime(new Date('2024-01-01'));

      await createMockSchedule(ctx.db, {
        frequency: 'MONTHLY',
        dayOfMonth: 15,
        nextRunDate: new Date('2024-01-15'),
      });

      const upcoming = await recurringEntryRouter.previewUpcoming({
        ctx,
        input: {
          toDate: new Date('2024-01-31'),
        },
      });

      expect(upcoming.length).toBeGreaterThan(0);
      expect(upcoming[0].scheduledDate).toEqual(new Date('2024-01-15'));
    });
  });

  describe('processRecurringSchedules', () => {
    it('should process due schedules', async () => {
      vi.setSystemTime(new Date('2024-01-31'));

      await createMockSchedule(ctx.db, {
        nextRunDate: new Date('2024-01-31'),
        status: 'ACTIVE',
      });

      const result = await processRecurringSchedules(ctx.db, ctx.notificationService);

      expect(result.successful).toBe(1);
    });

    it('should skip already processed schedules', async () => {
      vi.setSystemTime(new Date('2024-01-31'));

      const schedule = await createMockSchedule(ctx.db, {
        nextRunDate: new Date('2024-01-31'),
      });

      // Create existing execution
      await ctx.db.insert(scheduleExecutions).values({
        scheduleId: schedule.id,
        scheduledDate: new Date('2024-01-31'),
        executionType: 'AUTOMATIC',
        status: 'SUCCESS',
        startedAt: new Date(),
      });

      const result = await processRecurringSchedules(ctx.db, ctx.notificationService);

      expect(result.processed).toBe(0);
    });

    it('should mark schedule as ERROR after max retries', async () => {
      vi.setSystemTime(new Date('2024-01-31'));

      const schedule = await createMockSchedule(ctx.db, {
        nextRunDate: new Date('2024-01-31'),
        retryCount: 2,
        maxRetries: 3,
      });

      // Force error by using invalid template
      await ctx.db.update(recurringEntrySchedules)
        .set({ templateId: 'invalid-uuid' })
        .where(eq(recurringEntrySchedules.id, schedule.id));

      const result = await processRecurringSchedules(ctx.db, ctx.notificationService);

      const updated = await ctx.db.query.recurringEntrySchedules.findFirst({
        where: eq(recurringEntrySchedules.id, schedule.id),
      });

      expect(updated.status).toBe('ERROR');
    });
  });
});
```

### Integration Tests

```typescript
import { describe, it, expect, beforeAll, afterAll, vi } from 'vitest';
import { createTestDatabase, seedTestData, cleanupTestDatabase } from '@/test/db-utils';

describe('Recurring Entry Integration', () => {
  let db: TestDatabase;
  let testOrg: Organization;
  let testTemplate: Template;

  beforeAll(async () => {
    db = await createTestDatabase();
    const seed = await seedTestData(db);
    testOrg = seed.organization;
    testTemplate = await db.templates.create({
      organizationId: testOrg.id,
      templateName: 'Test Template',
      lines: [
        { accountId: seed.accounts[0].id, amountType: 'FIXED', fixedDebitAmount: 1000 },
        { accountId: seed.accounts[1].id, amountType: 'FIXED', fixedCreditAmount: 1000 },
      ],
    });
  });

  afterAll(async () => {
    await cleanupTestDatabase(db);
  });

  it('should complete full schedule lifecycle', async () => {
    vi.setSystemTime(new Date('2024-01-01'));

    // 1. Create schedule
    const schedule = await db.recurringSchedules.create({
      organizationId: testOrg.id,
      scheduleName: 'Monthly Rent',
      templateId: testTemplate.id,
      frequency: 'MONTHLY',
      dayOfMonth: 1,
      startDate: new Date('2024-01-01'),
      endDate: new Date('2024-12-31'),
    });

    expect(schedule.nextRunDate).toEqual(new Date('2024-01-01'));

    // 2. Process schedule
    await db.scheduler.processRecurringSchedules();

    // 3. Verify entry created
    const executions = await db.scheduleExecutions.findBySchedule(schedule.id);
    expect(executions).toHaveLength(1);
    expect(executions[0].status).toBe('SUCCESS');

    // 4. Check next run date updated
    const updated = await db.recurringSchedules.findById(schedule.id);
    expect(updated.nextRunDate).toEqual(new Date('2024-02-01'));

    // 5. Pause schedule
    await db.recurringSchedules.pause(schedule.id);

    // 6. Fast forward 3 months
    vi.setSystemTime(new Date('2024-04-01'));

    // 7. Resume with missed entries
    const resumeResult = await db.recurringSchedules.resume(schedule.id, { generateMissed: true });

    expect(resumeResult.missedEntriesGenerated).toBe(3); // Feb, Mar, Apr

    // 8. Verify all entries created
    const allExecutions = await db.scheduleExecutions.findBySchedule(schedule.id);
    expect(allExecutions).toHaveLength(4); // Jan + 3 missed
  });

  it('should handle end of month correctly', async () => {
    // Schedule for day 31
    const schedule = await db.recurringSchedules.create({
      organizationId: testOrg.id,
      scheduleName: 'Month End',
      templateId: testTemplate.id,
      frequency: 'MONTHLY',
      dayOfMonth: 31,
      endOfMonthHandling: 'LAST_DAY',
      startDate: new Date('2024-01-01'),
    });

    // January - 31st exists
    vi.setSystemTime(new Date('2024-01-31'));
    await db.scheduler.processRecurringSchedules();

    let updated = await db.recurringSchedules.findById(schedule.id);
    expect(updated.lastRunDate).toEqual(new Date('2024-01-31'));

    // February - 31st doesn't exist, should use 29th (leap year)
    expect(updated.nextRunDate).toEqual(new Date('2024-02-29'));
  });

  it('should skip weekends correctly', async () => {
    // Jan 27, 2024 is a Saturday
    const schedule = await db.recurringSchedules.create({
      organizationId: testOrg.id,
      scheduleName: 'Skip Weekend Test',
      templateId: testTemplate.id,
      frequency: 'MONTHLY',
      dayOfMonth: 27,
      skipWeekends: true,
      weekendAdjustment: 'PREVIOUS', // Should move to Friday 26th
      startDate: new Date('2024-01-01'),
    });

    expect(schedule.nextRunDate).toEqual(new Date('2024-01-26')); // Friday
  });
});
```

### E2E Tests

```typescript
import { test, expect } from '@playwright/test';

test.describe('Recurring Entry Schedules', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/accounting/recurring');
  });

  test('should create new recurring schedule', async ({ page }) => {
    await page.click('button:has-text("Create Schedule")');

    await page.fill('input[name="scheduleName"]', 'Monthly Depreciation');
    await page.selectOption('[name="templateId"]', { label: 'Depreciation Template' });
    await page.selectOption('[name="frequency"]', 'MONTHLY');
    await page.fill('input[name="dayOfMonth"]', '31');
    await page.fill('input[name="startDate"]', '2024-01-01');

    await page.click('button:has-text("Create Schedule")');

    await expect(page.locator('text=Schedule created successfully')).toBeVisible();
    await expect(page.locator('text=Monthly Depreciation')).toBeVisible();
  });

  test('should pause and resume schedule', async ({ page }) => {
    await page.click('text=Monthly Depreciation');

    // Pause
    await page.click('button:has-text("Pause")');
    await expect(page.locator('[data-status="PAUSED"]')).toBeVisible();

    // Resume
    await page.click('button:has-text("Resume")');
    await page.check('input[name="generateMissed"]');
    await page.click('button:has-text("Confirm Resume")');

    await expect(page.locator('[data-status="ACTIVE"]')).toBeVisible();
  });

  test('should preview upcoming entries', async ({ page }) => {
    await page.click('button:has-text("Preview Upcoming")');

    await expect(page.locator('[data-testid="upcoming-list"]')).toBeVisible();
    await expect(page.locator('[data-testid="upcoming-entry"]')).toHaveCount(12); // Next 12 months
  });

  test('should manually generate entry', async ({ page }) => {
    await page.click('text=Monthly Depreciation');
    await page.click('button:has-text("Generate Now")');

    await page.fill('input[name="entryDate"]', '2024-02-15');
    await page.click('button:has-text("Generate")');

    await expect(page.locator('text=Entry generated successfully')).toBeVisible();
  });

  test('should show execution history', async ({ page }) => {
    await page.click('text=Monthly Depreciation');
    await page.click('tab:has-text("History")');

    await expect(page.locator('[data-testid="execution-row"]')).toHaveCount.greaterThan(0);
  });
});
```

---

## Security Checklist

- [x] **Authentication**: All endpoints require authenticated session
- [x] **Authorization**: Users can only access schedules in their organization
- [x] **Row-Level Security**: PostgreSQL RLS enforces organization isolation
- [x] **Input Validation**: All inputs validated with Zod schemas
- [x] **Rate Limiting**: Scheduler job has retry limits
- [x] **Audit Trail**: All schedule operations logged
- [x] **Error Isolation**: Scheduler failures don't affect other schedules
- [x] **Notification Security**: Email recipients validated

---

## Audit Events

| Event | Trigger | Data Captured |
|-------|---------|---------------|
| `RECURRING_SCHEDULE_CREATED` | New schedule created | scheduleId, templateId, frequency, nextRunDate |
| `RECURRING_SCHEDULE_UPDATED` | Schedule modified | scheduleId, changes[] |
| `RECURRING_SCHEDULE_PAUSED` | Schedule paused | scheduleId, pausedBy |
| `RECURRING_SCHEDULE_RESUMED` | Schedule resumed | scheduleId, missedEntriesGenerated |
| `RECURRING_SCHEDULE_DELETED` | Schedule archived | scheduleId |
| `RECURRING_ENTRY_GENERATED` | Entry created from schedule | entryId, scheduleId, executionType |
| `RECURRING_ENTRY_FAILED` | Generation failed | scheduleId, errorMessage, retryCount |

---

## Implementation Notes

### Scheduler Job
- Runs via cron job (recommended: every 15 minutes)
- Processes all due schedules in a single batch
- Uses database transactions for each schedule
- Handles failures independently per schedule

### Date Calculations
- Uses date-fns for reliable date manipulation
- Handles leap years and month-end variations
- Time zone aware using organization settings

### Weekend/Holiday Handling
- PREVIOUS: Move to previous business day
- NEXT: Move to next business day
- NONE: Keep original date regardless

### End of Month Handling
- LAST_DAY: Use last day of month (Feb 28/29 for day 31)
- SKIP: Skip months without the target day
- FIRST_OF_NEXT: Use first day of next month

### Retry Logic
- Default 3 retries before marking ERROR
- Retries on next scheduler run
- Manual intervention needed for ERROR status

### Performance Considerations
- Index on next_run_date for efficient scheduler queries
- Batch processing with configurable concurrency
- Separate notification queue for async delivery
